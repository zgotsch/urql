{"version":3,"file":"urql-next.mjs","sources":["../src/DataHydrationContext.ts","../src/Provider.ts","../src/useUrqlValue.ts","../src/useQuery.ts"],"sourcesContent":["import React from 'react';\nimport { ServerInsertedHTMLContext } from 'next/navigation';\nimport type { UrqlResult } from './useUrqlValue';\n\ninterface DataHydrationValue {\n  isInjecting: boolean;\n  operationValuesByKey: Record<number, UrqlResult>;\n  RehydrateScript: () =>\n    | React.DetailedReactHTMLElement<\n        { dangerouslySetInnerHTML: { __html: string } },\n        HTMLElement\n      >\n    | React.FunctionComponentElement<any>;\n}\n\nconst DataHydrationContext = React.createContext<\n  DataHydrationValue | undefined\n>(undefined);\n\nfunction transportDataToJS(data: any) {\n  const key = 'urql_transport';\n  return `(window[Symbol.for(\"${key}\")] ??= []).push(\"${Buffer.from(\n    JSON.stringify(data),\n    'utf-8'\n  ).toString('base64')}\")`;\n}\n\nexport const DataHydrationContextProvider = ({\n  children,\n}: React.PropsWithChildren<{}>) => {\n  const dataHydrationContext = React.useRef<DataHydrationValue>();\n  if (typeof window == 'undefined') {\n    if (!dataHydrationContext.current)\n      dataHydrationContext.current = buildContext();\n  }\n\n  return React.createElement(\n    DataHydrationContext.Provider,\n    { value: dataHydrationContext.current },\n    children\n  );\n};\n\nexport function useDataHydrationContext(): DataHydrationValue | undefined {\n  const dataHydrationContext = React.useContext(DataHydrationContext);\n  const insertHtml = React.useContext(ServerInsertedHTMLContext);\n\n  if (typeof window !== 'undefined') return;\n\n  if (insertHtml && dataHydrationContext && !dataHydrationContext.isInjecting) {\n    dataHydrationContext.isInjecting = true;\n    insertHtml(() =>\n      React.createElement(dataHydrationContext.RehydrateScript, {})\n    );\n  }\n  return dataHydrationContext;\n}\n\nlet key = 0;\nfunction buildContext(): DataHydrationValue {\n  const dataHydrationContext: DataHydrationValue = {\n    isInjecting: false,\n    operationValuesByKey: {},\n    RehydrateScript() {\n      dataHydrationContext.isInjecting = false;\n      if (!Object.keys(dataHydrationContext.operationValuesByKey).length)\n        return React.createElement(React.Fragment);\n\n      const __html = transportDataToJS({\n        rehydrate: { ...dataHydrationContext.operationValuesByKey },\n      });\n\n      dataHydrationContext.operationValuesByKey = {};\n\n      return React.createElement('script', {\n        key: key++,\n        dangerouslySetInnerHTML: { __html },\n      });\n    },\n  };\n\n  return dataHydrationContext;\n}\n","'use client';\n\nimport React from 'react';\nimport type { SSRExchange, Client } from 'urql';\nimport { Provider } from 'urql';\nimport { DataHydrationContextProvider } from './DataHydrationContext';\n\nexport const SSRContext = React.createContext<SSRExchange | undefined>(\n  undefined\n);\n\n/** Provider for `@urql/next` during non-rsc interactions.\n *\n * @remarks\n * `Provider` accepts a {@link Client} and provides it to all GraphQL hooks, it\n * also accepts an {@link SSRExchange} to distribute data when re-hydrating\n * on the client.\n *\n * @example\n * ```tsx\n * import {\n *  UrqlProvider,\n *  ssrExchange,\n *  cacheExchange,\n *  fetchExchange,\n *  createClient,\n * } from '@urql/next';\n *\n * const ssr = ssrExchange();\n * const client = createClient({\n *   url: 'https://trygql.formidable.dev/graphql/basic-pokedex',\n *   exchanges: [cacheExchange, ssr, fetchExchange],\n *   suspense: true,\n * });\n *\n * export default function Layout({ children }: React.PropsWithChildren) {\n *   return (\n *     <UrqlProvider client={client} ssr={ssr}>\n *      {children}\n *     </UrqlProvider>\n *   );\n * }\n *\n * ```\n */\nexport function UrqlProvider({\n  children,\n  ssr,\n  client,\n}: React.PropsWithChildren<{ ssr: SSRExchange; client: Client }>) {\n  return React.createElement(\n    Provider,\n    { value: client },\n    React.createElement(\n      SSRContext.Provider,\n      { value: ssr },\n      React.createElement(DataHydrationContextProvider, {}, children)\n    )\n  );\n}\n","'use client';\n\nimport React from 'react';\nimport { useDataHydrationContext } from './DataHydrationContext';\nimport { SSRContext } from './Provider';\n\nexport const symbolString = 'urql_transport';\nexport const urqlTransportSymbol = Symbol.for(symbolString);\n\nexport type UrqlResult = { data?: any; error?: any; extensions?: any };\n\nexport function useUrqlValue(operationKey: number): void {\n  const ssrExchange = React.useContext(SSRContext);\n  const rehydrationContext = useDataHydrationContext();\n\n  if (!ssrExchange) {\n    throw new Error(\n      'Missing \"UrqlProvider\" component as a parent or did not pass in an \"ssrExchange\" to the Provider.'\n    );\n  }\n\n  if (typeof window == 'undefined') {\n    const data = ssrExchange.extractData();\n    if (rehydrationContext && data[operationKey]) {\n      const res = data[operationKey];\n      const parsed = {\n        ...res,\n        extensions: res.extensions\n          ? JSON.parse(res.extensions)\n          : res.extensions,\n        data: res.data ? JSON.parse(res.data) : res.data,\n        error: res.error,\n      };\n      rehydrationContext.operationValuesByKey[operationKey] = parsed;\n    }\n  } else {\n    let stores: Array<{ rehydrate: Record<number, UrqlResult> }>;\n    if (window[urqlTransportSymbol as any]) {\n      stores = (\n        window[urqlTransportSymbol as any] as unknown as Array<string>\n      ).map(s => JSON.parse(decodeBase64(s)));\n    } else {\n      stores = [];\n    }\n\n    const store = stores.find(\n      x => x && x.rehydrate && x.rehydrate[operationKey]\n    );\n    if (store) {\n      const result = store.rehydrate && store.rehydrate[operationKey];\n      if (result) {\n        delete store.rehydrate[operationKey];\n        ssrExchange.restoreData({\n          [operationKey]: {\n            extensions: JSON.stringify(result.extensions),\n            data: JSON.stringify(result.data),\n            error: result.error,\n          },\n        });\n        delete store.rehydrate[operationKey];\n      }\n    }\n  }\n}\n\nfunction decodeBase64(base64) {\n  const text = atob(base64);\n  const bytes = new Uint8Array(text.length);\n  for (let i = 0; i < text.length; i++) {\n    bytes[i] = text.charCodeAt(i);\n  }\n  const decoder = new TextDecoder(); // default is utf-8\n  return decoder.decode(bytes);\n}\n","'use client';\n\nimport type {\n  AnyVariables,\n  CombinedError,\n  GraphQLRequestParams,\n  Operation,\n  OperationContext,\n  RequestPolicy,\n} from 'urql';\nimport { createRequest, useQuery as orig_useQuery } from 'urql';\nimport { useUrqlValue } from './useUrqlValue';\n\n/** Input arguments for the {@link useQuery} hook.\n *\n * @param query - The GraphQL query that `useQuery` executes.\n * @param variables - The variables for the GraphQL query that `useQuery` executes.\n */\nexport type UseQueryArgs<\n  Variables extends AnyVariables = AnyVariables,\n  Data = any,\n> = {\n  /** Updates the {@link RequestPolicy} for the executed GraphQL query operation.\n   *\n   * @remarks\n   * `requestPolicy` modifies the {@link RequestPolicy} of the GraphQL query operation\n   * that `useQuery` executes, and indicates a caching strategy for cache exchanges.\n   *\n   * For example, when set to `'cache-and-network'`, {@link useQuery} will\n   * receive a cached result with `stale: true` and an API request will be\n   * sent in the background.\n   *\n   * @see {@link OperationContext.requestPolicy} for where this value is set.\n   */\n  requestPolicy?: RequestPolicy;\n  /** Updates the {@link OperationContext} for the executed GraphQL query operation.\n   *\n   * @remarks\n   * `context` may be passed to {@link useQuery}, to update the {@link OperationContext}\n   * of a query operation. This may be used to update the `context` that exchanges\n   * will receive for a single hook.\n   *\n   * Hint: This should be wrapped in a `useMemo` hook, to make sure that your\n   * component doesn’t infinitely update.\n   *\n   * @example\n   * ```ts\n   * const [result, reexecute] = useQuery({\n   *   query,\n   *   context: useMemo(() => ({\n   *     additionalTypenames: ['Item'],\n   *   }), [])\n   * });\n   * ```\n   */\n  context?: Partial<OperationContext>;\n  /** Prevents {@link useQuery} from automatically executing GraphQL query operations.\n   *\n   * @remarks\n   * `pause` may be set to `true` to stop {@link useQuery} from executing\n   * automatically. The hook will stop receiving updates from the {@link Client}\n   * and won’t execute the query operation, until either it’s set to `false`\n   * or the {@link UseQueryExecute} function is called.\n   *\n   * @see {@link https://urql.dev/goto/docs/basics/react-preact/#pausing-usequery} for\n   * documentation on the `pause` option.\n   */\n  pause?: boolean;\n} & GraphQLRequestParams<Data, Variables>;\n\n/** State of the current query, your {@link useQuery} hook is executing.\n *\n * @remarks\n * `UseQueryState` is returned (in a tuple) by {@link useQuery} and\n * gives you the updating {@link OperationResult} of GraphQL queries.\n *\n * Even when the query and variables passed to {@link useQuery} change,\n * this state preserves the prior state and sets the `fetching` flag to\n * `true`.\n * This allows you to display the previous state, while implementing\n * a separate loading indicator separately.\n */\nexport interface UseQueryState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n> {\n  /** Indicates whether `useQuery` is waiting for a new result.\n   *\n   * @remarks\n   * When `useQuery` is passed a new query and/or variables, it will\n   * start executing the new query operation and `fetching` is set to\n   * `true` until a result arrives.\n   *\n   * Hint: This is subtly different than whether the query is actually\n   * fetching, and doesn’t indicate whether a query is being re-executed\n   * in the background. For this, see {@link UseQueryState.stale}.\n   */\n  fetching: boolean;\n  /** Indicates that the state is not fresh and a new result will follow.\n   *\n   * @remarks\n   * The `stale` flag is set to `true` when a new result for the query\n   * is expected and `useQuery` is waiting for it. This may indicate that\n   * a new request is being requested in the background.\n   *\n   * @see {@link OperationResult.stale} for the source of this value.\n   */\n  stale: boolean;\n  /** The {@link OperationResult.data} for the executed query. */\n  data?: Data;\n  /** The {@link OperationResult.error} for the executed query. */\n  error?: CombinedError;\n  /** The {@link OperationResult.extensions} for the executed query. */\n  extensions?: Record<string, any>;\n  /** The {@link Operation} that the current state is for.\n   *\n   * @remarks\n   * This is the {@link Operation} that is currently being executed.\n   * When {@link UseQueryState.fetching} is `true`, this is the\n   * last `Operation` that the current state was for.\n   */\n  operation?: Operation<Data, Variables>;\n}\n\n/** Triggers {@link useQuery} to execute a new GraphQL query operation.\n *\n * @param opts - optionally, context options that will be merged with the hook's\n * {@link UseQueryArgs.context} options and the `Client`’s options.\n *\n * @remarks\n * When called, {@link useQuery} will re-execute the GraphQL query operation\n * it currently holds, even if {@link UseQueryArgs.pause} is set to `true`.\n *\n * This is useful for executing a paused query or re-executing a query\n * and get a new network result, by passing a new request policy.\n *\n * ```ts\n * const [result, reexecuteQuery] = useQuery({ query });\n *\n * const refresh = () => {\n *   // Re-execute the query with a network-only policy, skipping the cache\n *   reexecuteQuery({ requestPolicy: 'network-only' });\n * };\n * ```\n */\nexport type UseQueryExecute = (opts?: Partial<OperationContext>) => void;\n\n/** Result tuple returned by the {@link useQuery} hook.\n *\n * @remarks\n * Similarly to a `useState` hook’s return value,\n * the first element is the {@link useQuery}’s result and state,\n * a {@link UseQueryState} object,\n * and the second is used to imperatively re-execute the query\n * via a {@link UseQueryExecute} function.\n */\nexport type UseQueryResponse<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n> = [UseQueryState<Data, Variables>, UseQueryExecute];\n\n/** Hook to run a GraphQL query and get updated GraphQL results.\n *\n * @param args - a {@link UseQueryArgs} object, to pass a `query`, `variables`, and options.\n * @returns a {@link UseQueryResponse} tuple of a {@link UseQueryState} result, and re-execute function.\n *\n * @remarks\n * `useQuery` allows GraphQL queries to be defined and executed.\n * Given {@link UseQueryArgs.query}, it executes the GraphQL query with the\n * context’s {@link Client}.\n *\n * The returned result updates when the `Client` has new results\n * for the query, and changes when your input `args` change.\n *\n * Additionally, if the `suspense` option is enabled on the `Client`,\n * the `useQuery` hook will suspend instead of indicating that it’s\n * waiting for a result via {@link UseQueryState.fetching}.\n *\n * @see {@link https://urql.dev/goto/urql/docs/basics/react-preact/#queries} for `useQuery` docs.\n *\n * @example\n * ```ts\n * import { gql, useQuery } from 'urql';\n *\n * const TodosQuery = gql`\n *   query { todos { id, title } }\n * `;\n *\n * const Todos = () => {\n *   const [result, reexecuteQuery] = useQuery({\n *     query: TodosQuery,\n *     variables: {},\n *   });\n *   // ...\n * };\n * ```\n */\nexport function useQuery<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n>(args: UseQueryArgs<Variables, Data>): UseQueryResponse<Data, Variables> {\n  const request = createRequest(\n    args.query,\n    (args.variables || {}) as AnyVariables\n  );\n  useUrqlValue(request.key);\n\n  const [result, execute] = orig_useQuery(args);\n\n  useUrqlValue(request.key);\n\n  return [result, execute];\n}\n"],"names":["DataHydrationContext","React","createContext","undefined","DataHydrationContextProvider","children","dataHydrationContext","useRef","window","current","buildContext","isInjecting","operationValuesByKey","RehydrateScript","Object","keys","length","createElement","Fragment","__html","transportDataToJS","data","Buffer","from","JSON","stringify","toString","rehydrate","key","dangerouslySetInnerHTML","Provider","value","SSRContext","UrqlProvider","ssr","client","urqlTransportSymbol","Symbol","for","useUrqlValue","operationKey","ssrExchange","useContext","rehydrationContext","useDataHydrationContext","insertHtml","ServerInsertedHTMLContext","Error","extractData","res","parsed","extensions","parse","error","stores","map","s","decodeBase64","base64","text","atob","bytes","Uint8Array","i","charCodeAt","TextDecoder","decode","store","find","x","result","restoreData","useQuery","args","request","createRequest","query","variables","execute","orig_useQuery"],"mappings":"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"}